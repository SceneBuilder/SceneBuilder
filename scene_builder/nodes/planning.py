from pydantic_graph import BaseNode, GraphRunContext
from rich.console import Console

from scene_builder.definition.scene import Room
# from scene_builder.nodes.routing import DesignLoopRouter
from scene_builder.nodes.design import DesignLoopRouter
from scene_builder.workflow.agents import (
    floor_plan_agent,
    floor_size_agent,
    planning_agent,
)
from scene_builder.workflow.states import MainState

console = Console()


class FloorPlanNode(BaseNode[MainState]):
    async def run(self, ctx: GraphRunContext[MainState]) -> DesignLoopRouter:
        console.print("[bold cyan]Executing Agent:[/] Floor Plan Agent")
        # is_debug = ctx.state.global_config and ctx.state.global_config.debug

        console.print(
            "[bold green]Production mode: Generating intelligent room layout with LLM.[/]"
        )

        # Use LLM to analyze floor dimensions from text description
        console.print("[bold cyan]Step 1: Analyzing floor dimensions with LLM...[/]")
        floor_analysis_prompt = (
            f"Based on the user request: '{ctx.state.user_input}' and building plan: '{ctx.state.plan}', "
            f"estimate realistic floor dimensions for the main room. Consider the room type and its intended use."
        )
        llm_floor_dims_result = await floor_size_agent.run(floor_analysis_prompt)
        llm_floor_dims = llm_floor_dims_result.output
        console.print(
            f"[bold cyan]LLM Dimension Analysis:[/] {llm_floor_dims.width}x{llm_floor_dims.length}m (floor), height: {llm_floor_dims.ceiling_height}m, {llm_floor_dims.shape}"
        )

        # Generate rooms with LLM using dimensional context
        console.print(
            "[bold cyan]Step 2: Generating room layout with architectural intelligence...[/]"
        )
        room_generation_prompt = (
            f"Create a room layout for: {ctx.state.user_input}\n"
            f"Building plan context: {ctx.state.plan}\n"
            f"Recommended dimensions: {llm_floor_dims.width}m x {llm_floor_dims.length}m (floor area)\n"
            f"Room shape: {llm_floor_dims.shape}\n"
            f"Focus on creating one primary room that matches the user's request with appropriate sizing."  # TODO: multi rooms soon later
        )
        generated_rooms_result = await floor_plan_agent.run(room_generation_prompt)
        generated_rooms = generated_rooms_result.output

        # Apply LLM-analyzed dimensions to generated rooms
        console.print(
            "[bold cyan]Step 3: Applying LLM dimension analysis to rooms...[/]"
        )

        try:
            for room in generated_rooms:
                # Apply LLM-analyzed dimensions to the room
                room.floor_dimensions = llm_floor_dims
                # Note: room.boundary is already generated by the LLM with the requested shape
                console.print(
                    f"[bold green]✓ Applied dimensions to {room.id} with {len(room.boundary) if room.boundary else 0} boundary points[/]"
                )

        except Exception as room_error:
            console.print(f"[bold red]✗ Error applying dimensions: {room_error}[/]")
            raise room_error

        ctx.state.scene_definition.rooms.extend(generated_rooms)
        console.print(
            f"[bold cyan]✓ Successfully generated {len(generated_rooms)} room(s):[/] {[room.id for room in generated_rooms]}"
        )

        return DesignLoopRouter()


class BuildingPlanNode(BaseNode[MainState]):
    async def run(self, ctx: GraphRunContext[MainState]) -> FloorPlanNode:
        console.print("[bold cyan]Executing Node:[/] Scene Planning Node")

        console.print("[bold green]Production mode: Generating scene plan via LLM.[/]")
        response = await planning_agent.run(ctx.state.user_input)
        ctx.state.plan = response.content
        console.print(f"[bold cyan]Generated Plan:[/] {ctx.state.plan}")

        return FloorPlanNode()
